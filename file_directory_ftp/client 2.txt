import socket
import threading
import json
import struct
import os
import time
from datetime import datetime
import dearpygui.dearpygui as dpg

class ChatClient:
    def __init__(self, host='127.0.0.1', port=9999):
        self.host = host
        self.port = port
        self.client_socket = None
        self.username = None
        self.connected = False
        
        # Cartella per i file ricevuti
        self.download_dir = "downloads"
        if not os.path.exists(self.download_dir):
            os.makedirs(self.download_dir)
        
        # Inizializzazione GUI
        self.init_gui()
    
    def init_gui(self):
        dpg.create_context()
        dpg.create_viewport(title="Chat con condivisione file", width=800, height=600)
        dpg.setup_dearpygui()
        
        with dpg.window(label="Chat", width=800, height=600, tag="main_window"):
            with dpg.tab_bar(tag="tab_bar"):
                with dpg.tab(label="Login"):
                    dpg.add_input_text(label="Server IP", default_value="127.0.0.1", tag="server_ip")
                    dpg.add_input_text(label="Porta", default_value="9999", tag="server_port")
                    dpg.add_input_text(label="Username", tag="username_input")
                    dpg.add_button(label="Connetti", callback=self.connect_to_server)
                
                with dpg.tab(label="Chat", show=False, tag="chat_tab"):
                    # Area dei messaggi
                    with dpg.child_window(width=-1, height=400, tag="messages_window"):
                        dpg.add_text("Benvenuto nella chat!", tag="chat_messages")
                    
                    # Controlli per l'invio di messaggi e file
                    with dpg.group(horizontal=True):
                        dpg.add_input_text(tag="message_input", width=-250)
                        dpg.add_button(label="Invia", callback=self.send_text_message)
                    
                    dpg.add_separator()
                    
                    # Sezione per la condivisione file
                    dpg.add_text("Condivisione File")
                    with dpg.group(horizontal=True):
                        dpg.add_input_text(tag="file_path", width=-100, readonly=True)
                        dpg.add_button(label="Sfoglia", callback=self.open_file_dialog)
                    
                    with dpg.group(horizontal=True):
                        dpg.add_button(label="Invia File", callback=self.send_file)
                        dpg.add_combo(["Testo", "Audio", "Video", "Altro"], default_value="Altro", tag="file_type")
        
        # File dialog
        with dpg.file_dialog(directory_selector=False, show=False, callback=self.file_selected, tag="file_dialog"):
            dpg.add_file_extension(".*")
            dpg.add_file_extension(".txt", color=(0, 255, 0, 255))
            dpg.add_file_extension(".mp3", color=(0, 255, 255, 255))
            dpg.add_file_extension(".mp4", color=(255, 0, 255, 255))
        
        # Aggiungiamo un popup per le notifiche
        with dpg.window(label="Notifica", modal=True, show=False, tag="notification_popup", 
                       no_resize=True, width=300, height=100):
            dpg.add_text("", tag="notification_text")
            dpg.add_button(label="OK", callback=lambda: dpg.configure_item("notification_popup", show=False))
        
        dpg.show_viewport()
    
    def open_file_dialog(self):
        dpg.show_item("file_dialog")
    
    def file_selected(self, sender, app_data):
        # app_data contiene i file selezionati
        if "file_path_name" in app_data:
            selected_file = app_data["file_path_name"]
            dpg.set_value("file_path", selected_file)
    
    def show_notification(self, message):
        dpg.set_value("notification_text", message)
        dpg.configure_item("notification_popup", show=True)
    
    def add_message(self, message, is_system=False):
        current_text = dpg.get_value("chat_messages")
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        if is_system:
            new_text = f"{current_text}\n[{timestamp}] [SISTEMA] {message}"
        else:
            new_text = f"{current_text}\n[{timestamp}] {message}"
        
        dpg.set_value("chat_messages", new_text)
        # Auto-scroll
        dpg.set_y_scroll("messages_window", -1)
    
    def connect_to_server(self):
        if self.connected:
            self.show_notification("Sei già connesso!")
            return
        
        server_ip = dpg.get_value("server_ip")
        server_port = int(dpg.get_value("server_port"))
        self.username = dpg.get_value("username_input")
        
        if not self.username:
            self.show_notification("Inserisci un username!")
            return
        
        try:
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.connect((server_ip, server_port))
            
            # Invia username al server
            login_message = {
                'type': 'login',
                'username': self.username
            }
            self.send_message(login_message)
            
            # Avvia thread per ascoltare i messaggi
            receiver_thread = threading.Thread(target=self.receive_messages)
            receiver_thread.daemon = True
            receiver_thread.start()
            
            self.connected = True
            
            # Cambia visibilità delle tab
            dpg.configure_item("chat_tab", show=True)
            dpg.set_value("tab_bar", "chat_tab")
            
            self.add_message(f"Connesso al server come {self.username}", True)
            
        except Exception as e:
            self.show_notification(f"Errore di connessione: {str(e)}")
    
    def disconnect(self):
        if self.connected and self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
            self.connected = False
            self.add_message("Disconnesso dal server", True)
    
    def send_message(self, message_dict):
        # Serializza il messaggio in JSON
        message_json = json.dumps(message_dict).encode('utf-8')
        
        # Invia la lunghezza del messaggio come header
        header = struct.pack("!I", len(message_json))
        self.client_socket.sendall(header + message_json)
    
    def send_text_message(self):
        if not self.connected:
            self.show_notification("Non sei connesso al server!")
            return
        
        message_text = dpg.get_value("message_input")
        if not message_text:
            return
        
        message = {
            'type': 'text_message',
            'username': self.username,
            'content': message_text,
            'timestamp': time.time()
        }
        
        try:
            self.send_message(message)
            # Aggiungiamo il messaggio alla nostra GUI subito, senza aspettare l'echo dal server
            self.add_message(f"{self.username}: {message_text}")
            dpg.set_value("message_input", "")  # Pulisce il campo di input
        except Exception as e:
            self.show_notification(f"Errore nell'invio del messaggio: {str(e)}")
            self.disconnect()
    
    def send_file(self):
        if not self.connected:
            self.show_notification("Non sei connesso al server!")
            return
        
        file_path = dpg.get_value("file_path")
        
        if not file_path or not os.path.exists(file_path):
            self.show_notification("Seleziona un file valido!")
            return
        
        file_type = dpg.get_value("file_type").lower()
        file_name = os.path.basename(file_path)
        file_size = os.path.getsize(file_path)
        
        # Prepara l'header per il file
        file_header = {
            'type': 'file',
            'file_type': file_type,
            'filename': file_name,
            'file_size': file_size,
            'username': self.username,
            'timestamp': time.time()
        }
        
        try:
            # Invia l'header del file
            self.send_message(file_header)
            
            # Invia il contenuto del file
            with open(file_path, 'rb') as file:
                # Legge e invia il file in chunk
                chunk_size = 4096
                while True:
                    chunk = file.read(chunk_size)
                    if not chunk:
                        break
                    self.client_socket.sendall(chunk)
            
            # Anche qui, aggiorniamo la nostra GUI subito
            self.add_message(f"Hai condiviso un file {file_type}: {file_name}", True)
            
        except Exception as e:
            self.show_notification(f"Errore nell'invio del file: {str(e)}")
            self.disconnect()
    
    def receive_messages(self):
        while self.connected:
            try:
                # Ricevi lunghezza dell'header
                header_size_data = self.client_socket.recv(4)
                if not header_size_data:
                    break
                
                header_size = struct.unpack("!I", header_size_data)[0]
                
                # Ricevi l'header JSON
                header_data = self.client_socket.recv(header_size)
                header = json.loads(header_data.decode('utf-8'))
                
                message_type = header.get('type')
                
                if message_type == 'text_message':
                    username = header.get('username', 'Anonimo')
                    content = header.get('content', '')
                    
                    # Mostra tutti i messaggi in arrivo
                    # Il server non invierà i nostri messaggi di nuovo a noi
                    self.add_message(f"{username}: {content}")
                
                elif message_type == 'file':
                    username = header.get('username', 'Anonimo')
                    filename = header.get('filename', 'unknown')
                    file_size = header.get('file_size', 0)
                    file_type = header.get('file_type', 'unknown')
                    
                    # Aggiorna l'interfaccia con la notifica di arrivo del file
                    self.add_message(f"{username} ha condiviso un file {file_type}: {filename}", True)
                    self.add_message(f"Ricezione file da {username}: {filename} ({file_size} bytes)", True)
                    
                    # Percorso dove salvare il file
                    save_path = os.path.join(self.download_dir, filename)
                    
                    # Ricevi il file
                    with open(save_path, 'wb') as file:
                        bytes_received = 0
                        chunk_size = 4096
                        
                        while bytes_received < file_size:
                            bytes_to_receive = min(chunk_size, file_size - bytes_received)
                            chunk = self.client_socket.recv(bytes_to_receive)
                            if not chunk:
                                break
                            file.write(chunk)
                            bytes_received += len(chunk)
                    
                    self.add_message(f"File ricevuto: {filename} - Salvato in {save_path}", True)
                
                elif message_type == 'user_joined':
                    username = header.get('username', 'Anonimo')
                    self.add_message(f"{username} è entrato nella chat", True)
                
                elif message_type == 'user_left':
                    username = header.get('username', 'Anonimo')
                    self.add_message(f"{username} è uscito dalla chat", True)
                
                elif message_type == 'error':
                    error_message = header.get('message', 'Errore sconosciuto')
                    self.add_message(f"ERRORE: {error_message}", True)
            
            except Exception as e:
                self.add_message(f"Errore nella ricezione: {str(e)}", True)
                break
        
        # Se usciamo dal loop, siamo disconnessi
        self.connected = False
        self.add_message("Connessione al server persa", True)
    
    def run(self):
        while dpg.is_dearpygui_running():
            dpg.render_dearpygui_frame()
        
        # Cleanup alla chiusura
        self.disconnect()
        dpg.destroy_context()

# main_client.py - Per avviare il client
if __name__ == "__main__":
    client = ChatClient()
    client.run()